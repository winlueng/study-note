# Java **多线程**总结
#### 一. java线程的运行机制

1. 每个线程都有一个独立的程序计数器和方法调用盏
2. 每当用java命令启动一个java虚拟机进程时, jvm就会创建一个主线程, 线程从程序入口main()方法开始执行

#### 二. 线程的创建和启动
创建线程有两种方式: 
1. 拓展/继承java.lang.Thread类
2. 实现Runnable接口
##### ps: 实现Runnable接口是最常用的, 实现接口优于继承对象

#### 三. 线程的状态转换
1. 新建状态(new)
2. 就绪状态(runnable)
3. 运行状态(running)
4. 阻塞状态(blocked)
5. 死亡状态(dead)

#### 四. 线程调度
有两种调度模型: 
1. 分时调度模型
2. 抢占式调度模型

##### ps: jvm采用抢占式调度模型, 采用优先级调度比分时调度更利于业务需求(但也要注意服务器操作系统, 因为线程调度不是跨平台的, 不仅取决于jvm, 还依赖着操作系统)

#### 五. 线程同步
1. 每个java对象都有且只有一个同步锁, 任何情况下, 只允许一个线程拥有这把锁
2. 线程同步具有以下特征:
-  一个同步代码块和非同步代码块操作共享资源, 仍然会造成对资源的竞争.
-  每个对象都有唯一的同步锁
-  静态方法下也可以使用  **synchronized** 修饰符
-  当一个线程开始执行同步代码块, 并不以为着必须以不中断的方式运行(不是终结线程), 此时只是并非释放锁, 而是给机会让其他线程获取cpu
-  **synchronized**不会被继承

#### 六. 同步与并发
1. 同步是解决共享资源竞争的有效手段, 但多线程的同步与并发是一对此消彼长的**矛盾**
2. 提高并发性能, 应该使得同步代码块中包含尽可能少的操作, 使得一个线程尽快释放锁, 减少其他线程等待时间.

#### 七. 线程安全
1. 一个线程安全的类满足一下条件:
-  这个类的对象可以同时被多个线程安全访问
-  每个线程都能正常执行原子操作, 得到正确结果
-  每个线程的原子操作完成后, 对象处于逻辑上的合理状态

2. 不可变类总是线程安全的
3. 可变类的线程安全往往以降低并发性能为代价, 为了减小这一负面影响, 可以采用以下措施:
- 只对可能导致资源竞争的代码进行同步
- 如果一个可变类有两种运行环境: 单线程运行环境和多线程运行环境, 那么可以为这个类提供两种实现, 在单线程运行环境中使用未采取同步的类的实现, 在多线程运行环境中使用采取同步的类的实现.
##### ps: 所谓单线程运行环境, 是指类的对象只会被一个线程访问, 所谓多线程运行环境, 是指类的同一个对象被多个线程同时访问

#### 八. 释放对象的锁
1. 以下情况持有锁的线程会释放锁:
- 执行完同步代码块
- 在执行同步代码块的过程中, 遇到异常而导致线程终止
- 在执行同步代码块的过程中, 执行了锁所属对象的wait()方法, 这个线程会释放锁, 进入对象的等待池
2. 以下情况持有锁的线程不会释放锁
- 在执行同步代码块的过程中, 当前线程因进入sleep睡眠而放弃cpu, 睡眠中是不会释放锁的
- 在执行同步代码块的过程中, 当前线程主动yield让出cpu进入就绪态
- 在执行同步代码块的过程中, 其他线程执行了当前线程对象的suspend()方法(**此方法已经被废弃**)

#### 九. 死锁
当一个线程等待由另一个线程持有的锁, 而后者正在等待已被前者线程持有的锁时, 就会发生死锁

#### 十. 线程通信
不同线程执行不同的任务, 如果这些任务有某种联系, 线程之间必须能够通信, 协调完成工作. 

##### ps: java.lang.Object类中提供wait()和notify()方法. 

#### 十一. concurrent并发包
**11.1** 为保证线程的同步, 同时避免死锁, 兼顾并发性能, 从而在jdk5增加java.util.concurrent并发包
##### 主要包括:
> 1. 用于线程同步的==Lock外部锁接口==
> 2. 用于线程通信的==Condition条件接口==
> 3. 支持异步运算的==Callable接口==和==Future接口==. (所谓异步运算, 是指线程A负责运算, 线程B等待获取线程A的运算结果)
> 4. 利用线程池来搞笑管理多个线程的==Executors类==和==Executors接口==
> 5. 支持线程同步的==BlockingQueue==阻塞队列接口
> 6. 线程安全的集合


**11.2** 用于线程同步的Lock外部锁

每个java对象都有一个 用于同步的锁, 但这实际上是概念上的锁. 而在java.util.cuncurrent.locks包中, Lock接口及它的实际类专门表示用于同步的锁.